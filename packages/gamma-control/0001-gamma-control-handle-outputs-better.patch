From bef7602ddcde50c7dccff992973f8ca08a2d6382 Mon Sep 17 00:00:00 2001
From: ErrorNoInternet <errornointernet@envs.net>
Date: Tue, 10 Sep 2024 13:38:08 +0800
Subject: [PATCH] gamma-control: handle outputs better

---
 .gitignore      |   1 +
 gamma-control.c | 504 ++++++++++++++++++++++++++++++++++--------------
 meson.build     |   2 +-
 str_vec.c       |  30 +++
 str_vec.h       |  15 ++
 5 files changed, 401 insertions(+), 151 deletions(-)
 create mode 100644 str_vec.c
 create mode 100644 str_vec.h

diff --git a/.gitignore b/.gitignore
index d73983b..d8d4f1a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
 /subprojects/
+/.cache
diff --git a/gamma-control.c b/gamma-control.c
index 69d1cd7..80e62d4 100644
--- a/gamma-control.c
+++ b/gamma-control.c
@@ -1,5 +1,9 @@
 #define _POSIX_C_SOURCE 200809L
+#include "str_vec.h"
+#include "wlr-gamma-control-unstable-v1-client-protocol.h"
 #include <errno.h>
+#include <math.h>
+#include <stdbool.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -8,187 +12,387 @@
 #include <unistd.h>
 #include <wayland-client-protocol.h>
 #include <wayland-client.h>
-#include "wlr-gamma-control-unstable-v1-client-protocol.h"
 
-struct output {
-	struct wl_output *wl_output;
-	struct zwlr_gamma_control_v1 *gamma_control;
-	uint32_t ramp_size;
-	int table_fd;
-	uint16_t *table;
-	struct wl_list link;
+struct config {
+    double contrast;
+    double brightness;
+    double gamma;
+    struct str_vec output_names;
 };
 
-static struct wl_list outputs;
-static struct zwlr_gamma_control_manager_v1 *gamma_control_manager = NULL;
+struct context {
+    struct config config;
+    bool new_output;
+    struct wl_list outputs;
+    struct zwlr_gamma_control_manager_v1 *gamma_control_manager;
+};
+
+struct output {
+    struct wl_list link;
+
+    struct context *context;
+    struct wl_output *wl_output;
+    struct zwlr_gamma_control_v1 *gamma_control;
+
+    int table_fd;
+    uint32_t id;
+    uint32_t ramp_size;
+    uint16_t *table;
+    bool enabled;
+    char *name;
+};
 
 static int create_anonymous_file(off_t size) {
-	char template[] = "/tmp/wlroots-shared-XXXXXX";
-	int fd = mkstemp(template);
-	if (fd < 0) {
-		return -1;
-	}
-
-	int ret;
-	do {
-		errno = 0;
-		ret = ftruncate(fd, size);
-	} while (errno == EINTR);
-	if (ret < 0) {
-		close(fd);
-		return -1;
-	}
-
-	unlink(template);
-	return fd;
+    char template[] = "/tmp/wlroots-shared-XXXXXX";
+    int fd = mkstemp(template);
+    if (fd < 0) {
+        return -1;
+    }
+
+    int ret;
+    do {
+        errno = 0;
+        ret = ftruncate(fd, size);
+    } while (errno == EINTR);
+    if (ret < 0) {
+        close(fd);
+        return -1;
+    }
+
+    unlink(template);
+    return fd;
 }
 
 static int create_gamma_table(uint32_t ramp_size, uint16_t **table) {
-	size_t table_size = ramp_size * 3 * sizeof(uint16_t);
-	int fd = create_anonymous_file(table_size);
-	if (fd < 0) {
-		fprintf(stderr, "failed to create anonymous file\n");
-		return -1;
-	}
+    size_t table_size = ramp_size * 3 * sizeof(uint16_t);
+    int fd = create_anonymous_file(table_size);
+    if (fd < 0) {
+        fprintf(stderr, "failed to create anonymous file\n");
+        return -1;
+    }
 
-	void *data =
-		mmap(NULL, table_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-	if (data == MAP_FAILED) {
-		fprintf(stderr, "failed to mmap()\n");
-		close(fd);
-		return -1;
-	}
+    void *data =
+        mmap(NULL, table_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    if (data == MAP_FAILED) {
+        fprintf(stderr, "failed to mmap()\n");
+        close(fd);
+        return -1;
+    }
 
-	*table = data;
-	return fd;
+    *table = data;
+    return fd;
 }
 
-static void gamma_control_handle_gamma_size(void *data,
-		struct zwlr_gamma_control_v1 *gamma_control, uint32_t ramp_size) {
-	struct output *output = data;
-	output->ramp_size = ramp_size;
-	output->table_fd = create_gamma_table(ramp_size, &output->table);
-	if (output->table_fd < 0) {
-		exit(EXIT_FAILURE);
-	}
+static void
+gamma_control_handle_gamma_size(void *data,
+                                struct zwlr_gamma_control_v1 *gamma_control,
+                                uint32_t ramp_size) {
+    struct output *output = data;
+    if (output->table_fd != -1) {
+        close(output->table_fd);
+        output->table_fd = -1;
+    }
+    output->ramp_size = ramp_size;
+    if (ramp_size == 0) {
+        zwlr_gamma_control_v1_destroy(output->gamma_control);
+        output->gamma_control = NULL;
+        return;
+    }
+    output->table_fd = create_gamma_table(ramp_size, &output->table);
+    output->context->new_output = true;
+    if (output->table_fd < 0) {
+        fprintf(stderr, "could not create gamma table for output %s (%d)\n",
+                output->name, output->id);
+        exit(EXIT_FAILURE);
+    }
 }
 
-static void gamma_control_handle_failed(void *data,
-		struct zwlr_gamma_control_v1 *gamma_control) {
-	fprintf(stderr, "failed to set gamma table\n");
-	exit(EXIT_FAILURE);
+static void
+gamma_control_handle_failed(void *data,
+                            struct zwlr_gamma_control_v1 *gamma_control) {
+    struct output *output = data;
+    fprintf(stderr, "gamma control of output %s (%d) failed\n", output->name,
+            output->id);
+    zwlr_gamma_control_v1_destroy(output->gamma_control);
+    output->gamma_control = NULL;
+    if (output->table_fd != -1) {
+        close(output->table_fd);
+        output->table_fd = -1;
+    }
 }
 
 static const struct zwlr_gamma_control_v1_listener gamma_control_listener = {
-	.gamma_size = gamma_control_handle_gamma_size,
-	.failed = gamma_control_handle_failed,
+    .gamma_size = gamma_control_handle_gamma_size,
+    .failed = gamma_control_handle_failed,
+};
+
+static void fill_gamma_table(uint16_t *table, uint32_t ramp_size,
+                             double contrast, double brightness, double gamma) {
+    uint16_t *r = table;
+    uint16_t *g = table + ramp_size;
+    uint16_t *b = table + 2 * ramp_size;
+    for (uint32_t i = 0; i < ramp_size; ++i) {
+        double val = (double)i / (ramp_size - 1);
+        val = contrast * pow(val, 1.0 / gamma) + (brightness - 1);
+        if (val > 1.0) {
+            val = 1.0;
+        } else if (val < 0.0) {
+            val = 0.0;
+        }
+        r[i] = g[i] = b[i] = (uint16_t)(UINT16_MAX * val);
+    }
+}
+
+static void setup_gamma_control(struct context *ctx, struct output *output) {
+    if (output->gamma_control != NULL) {
+        return;
+    }
+    if (ctx->gamma_control_manager == NULL) {
+        fprintf(
+            stderr,
+            "skipping setup of output %s (%d): gamma_control_manager missing\n",
+            output->name, output->id);
+        return;
+    }
+    output->gamma_control = zwlr_gamma_control_manager_v1_get_gamma_control(
+        ctx->gamma_control_manager, output->wl_output);
+    zwlr_gamma_control_v1_add_listener(output->gamma_control,
+                                       &gamma_control_listener, output);
+}
+
+static void output_set_whitepoint(struct output *output, struct config *cfg) {
+    if (!output->enabled || output->gamma_control == NULL ||
+        output->table_fd == -1) {
+        return;
+    }
+    fill_gamma_table(output->table, output->ramp_size, cfg->contrast,
+                     cfg->brightness, cfg->gamma);
+    lseek(output->table_fd, 0, SEEK_SET);
+    zwlr_gamma_control_v1_set_gamma(output->gamma_control, output->table_fd);
+}
+
+static void set_values(struct wl_list *outputs, struct config *cfg) {
+    fprintf(stderr, "setting values\n");
+    struct output *output;
+    wl_list_for_each(output, outputs, link) {
+        if (output->gamma_control == NULL) {
+            setup_gamma_control(output->context, output);
+            continue;
+        }
+        output_set_whitepoint(output, cfg);
+    }
+}
+
+static void wl_output_handle_geometry(void *data, struct wl_output *output,
+                                      int x, int y, int width, int height,
+                                      int subpixel, const char *make,
+                                      const char *model, int transform) {
+    (void)data, (void)output, (void)x, (void)y, (void)width, (void)height,
+        (void)subpixel, (void)make, (void)model, (void)transform;
+}
+
+static void wl_output_handle_mode(void *data, struct wl_output *output,
+                                  uint32_t flags, int width, int height,
+                                  int refresh) {
+    (void)data, (void)output, (void)flags, (void)width, (void)height,
+        (void)refresh;
+}
+
+static void wl_output_handle_done(void *data, struct wl_output *wl_output) {
+    (void)wl_output;
+    struct output *output = data;
+    setup_gamma_control(output->context, output);
+}
+
+static void wl_output_handle_scale(void *data, struct wl_output *output,
+                                   int scale) {
+    (void)data, (void)output, (void)scale;
+}
+
+static void wl_output_handle_name(void *data, struct wl_output *wl_output,
+                                  const char *name) {
+    (void)wl_output;
+    struct output *output = data;
+    output->name = strdup(name);
+    struct config *cfg = &output->context->config;
+    for (size_t idx = 0; idx < cfg->output_names.len; ++idx) {
+        if (strcmp(output->name, cfg->output_names.data[idx]) == 0) {
+            fprintf(stderr, "enabling output %s by name\n", output->name);
+            output->enabled = true;
+            return;
+        }
+    }
+}
+
+static void wl_output_handle_description(void *data,
+                                         struct wl_output *wl_output,
+                                         const char *description) {
+    (void)wl_output;
+    struct output *output = data;
+    struct config *cfg = &output->context->config;
+    for (size_t idx = 0; idx < cfg->output_names.len; ++idx) {
+        if (strcmp(description, cfg->output_names.data[idx]) == 0) {
+            fprintf(stderr, "enabling output %s by description\n", description);
+            output->enabled = true;
+            return;
+        }
+    }
+}
+
+struct wl_output_listener wl_output_listener = {
+    .geometry = wl_output_handle_geometry,
+    .mode = wl_output_handle_mode,
+    .done = wl_output_handle_done,
+    .scale = wl_output_handle_scale,
+    .name = wl_output_handle_name,
+    .description = wl_output_handle_description,
 };
 
 static void registry_handle_global(void *data, struct wl_registry *registry,
-		uint32_t name, const char *interface, uint32_t version) {
-	if (strcmp(interface, wl_output_interface.name) == 0) {
-		struct output *output = calloc(1, sizeof(*output));
-		output->wl_output = wl_registry_bind(registry, name,
-			&wl_output_interface, 1);
-		wl_list_insert(&outputs, &output->link);
-	} else if (strcmp(interface,
-			zwlr_gamma_control_manager_v1_interface.name) == 0) {
-		gamma_control_manager = wl_registry_bind(registry, name,
-			&zwlr_gamma_control_manager_v1_interface, 1);
-	}
+                                   uint32_t name, const char *interface,
+                                   uint32_t version) {
+    struct context *ctx = (struct context *)data;
+    if (strcmp(interface, wl_output_interface.name) == 0) {
+        fprintf(stderr, "registry: adding output %d\n", name);
+
+        struct output *output = calloc(1, sizeof(*output));
+        output->id = name;
+        output->table_fd = -1;
+        output->context = ctx;
+
+        if (version >= WL_OUTPUT_NAME_SINCE_VERSION) {
+            output->enabled = ctx->config.output_names.len == 0;
+            output->wl_output =
+                wl_registry_bind(registry, name, &wl_output_interface,
+                                 WL_OUTPUT_NAME_SINCE_VERSION);
+            wl_output_add_listener(output->wl_output, &wl_output_listener,
+                                   output);
+        } else {
+            fprintf(
+                stderr,
+                "wl_output: old version (%d < %d), disabling name support\n",
+                version, WL_OUTPUT_NAME_SINCE_VERSION);
+            output->enabled = true;
+            output->wl_output =
+                wl_registry_bind(registry, name, &wl_output_interface, version);
+            setup_gamma_control(ctx, output);
+        }
+
+        wl_list_insert(&ctx->outputs, &output->link);
+    } else if (strcmp(interface,
+                      zwlr_gamma_control_manager_v1_interface.name) == 0) {
+        ctx->gamma_control_manager = wl_registry_bind(
+            registry, name, &zwlr_gamma_control_manager_v1_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data,
-		struct wl_registry *registry, uint32_t name) {
-	// Who cares?
+                                          struct wl_registry *registry,
+                                          uint32_t name) {
+    struct context *ctx = (struct context *)data;
+    struct output *output, *tmp;
+    wl_list_for_each_safe(output, tmp, &ctx->outputs, link) {
+        if (output->id == name) {
+            fprintf(stderr, "registry: removing output %s (%d)\n", output->name,
+                    name);
+            free(output->name);
+            wl_list_remove(&output->link);
+            if (output->gamma_control != NULL) {
+                zwlr_gamma_control_v1_destroy(output->gamma_control);
+            }
+            if (output->table_fd != -1) {
+                close(output->table_fd);
+            }
+            free(output);
+            break;
+        }
+    }
 }
 
 static const struct wl_registry_listener registry_listener = {
-	.global = registry_handle_global,
-	.global_remove = registry_handle_global_remove,
+    .global = registry_handle_global,
+    .global_remove = registry_handle_global_remove,
 };
 
-static void fill_gamma_table(uint16_t *table, uint32_t ramp_size,
-		double contrast, double brightness, double gamma) {
-	uint16_t *r = table;
-	uint16_t *g = table + ramp_size;
-	uint16_t *b = table + 2 * ramp_size;
-	for (uint32_t i = 0; i < ramp_size; ++i) {
-		double val = (double)i / (ramp_size - 1);
-		val = contrast * pow(val, 1.0 / gamma) + (brightness - 1);
-		if (val > 1.0) {
-			val = 1.0;
-		} else if (val < 0.0) {
-			val = 0.0;
-		}
-		r[i] = g[i] = b[i] = (uint16_t)(UINT16_MAX * val);
-	}
+static int wlrun(struct config cfg) {
+    struct context ctx = {
+        .config = cfg,
+    };
+    wl_list_init(&ctx.outputs);
+
+    struct wl_display *display = wl_display_connect(NULL);
+    if (display == NULL) {
+        fprintf(stderr, "failed to create display\n");
+        return EXIT_FAILURE;
+    }
+
+    struct wl_registry *registry = wl_display_get_registry(display);
+    wl_registry_add_listener(registry, &registry_listener, &ctx);
+    wl_display_roundtrip(display);
+
+    if (ctx.gamma_control_manager == NULL) {
+        fprintf(stderr,
+                "compositor doesn't support wlr-gamma-control-unstable-v1\n");
+        return EXIT_FAILURE;
+    }
+
+    struct output *output;
+    wl_list_for_each(output, &ctx.outputs, link) {
+        setup_gamma_control(&ctx, output);
+    }
+    wl_display_roundtrip(display);
+
+    set_values(&ctx.outputs, &ctx.config);
+
+    while (wl_display_dispatch(display) != -1) {
+        if (ctx.new_output) {
+            ctx.new_output = false;
+            set_values(&ctx.outputs, &cfg);
+        }
+    }
+
+    return EXIT_SUCCESS;
 }
 
 static const char usage[] = "usage: gamma-control [options]\n"
-	"  -h          show this help message\n"
-	"  -c <value>  set contrast (default: 1)\n"
-	"  -b <value>  set brightness (default: 1)\n"
-	"  -g <value>  set gamma (default: 1)\n";
+                            "  -h           show this help message\n"
+                            "  -o <output>  name of output to use\n"
+                            "  -c <value>   set contrast (default: 1)\n"
+                            "  -b <value>   set brightness (default: 1)\n"
+                            "  -g <value>   set gamma (default: 1)\n";
 
 int main(int argc, char *argv[]) {
-	wl_list_init(&outputs);
-
-	double contrast = 1, brightness = 1, gamma = 1;
-	int opt;
-	while ((opt = getopt(argc, argv, "hc:b:g:")) != -1) {
-		switch (opt) {
-		case 'c':
-			contrast = strtod(optarg, NULL);
-			break;
-		case 'b':
-			brightness = strtod(optarg, NULL);
-			break;
-		case 'g':
-			gamma = strtod(optarg, NULL);
-			break;
-		case 'h':
-		default:
-			fprintf(stderr, usage);
-			return opt == 'h' ? EXIT_SUCCESS : EXIT_FAILURE;
-		}
-	}
-
-	struct wl_display *display = wl_display_connect(NULL);
-	if (display == NULL) {
-		fprintf(stderr, "failed to create display\n");
-		return -1;
-	}
-
-	struct wl_registry *registry = wl_display_get_registry(display);
-	wl_registry_add_listener(registry, &registry_listener, NULL);
-	wl_display_roundtrip(display);
-
-	if (gamma_control_manager == NULL) {
-		fprintf(stderr,
-			"compositor doesn't support wlr-gamma-control-unstable-v1\n");
-		return EXIT_FAILURE;
-	}
-
-	struct output *output;
-	wl_list_for_each(output, &outputs, link) {
-		output->gamma_control = zwlr_gamma_control_manager_v1_get_gamma_control(
-			gamma_control_manager, output->wl_output);
-		zwlr_gamma_control_v1_add_listener(output->gamma_control,
-			&gamma_control_listener, output);
-	}
-	wl_display_roundtrip(display);
-
-	wl_list_for_each(output, &outputs, link) {
-		fill_gamma_table(output->table, output->ramp_size,
-			contrast, brightness, gamma);
-		zwlr_gamma_control_v1_set_gamma(output->gamma_control,
-			output->table_fd);
-	}
-
-	while (wl_display_dispatch(display) != -1) {
-		// This space is intentionnally left blank
-	}
-
-	return EXIT_SUCCESS;
+    struct config config = {
+        .contrast = 1,
+        .brightness = 1,
+        .gamma = 1,
+    };
+    str_vec_init(&config.output_names);
+
+    int ret = EXIT_FAILURE;
+    int opt;
+    while ((opt = getopt(argc, argv, "ho:c:b:g:")) != -1) {
+        switch (opt) {
+        case 'o':
+            str_vec_push(&config.output_names, optarg);
+            break;
+        case 'c':
+            config.contrast = strtod(optarg, NULL);
+            break;
+        case 'b':
+            config.brightness = strtod(optarg, NULL);
+            break;
+        case 'g':
+            config.gamma = strtod(optarg, NULL);
+            break;
+        case 'h':
+        default:
+            fprintf(stderr, usage);
+            return opt == 'h' ? EXIT_SUCCESS : EXIT_FAILURE;
+        }
+    }
+
+    ret = wlrun(config);
+    str_vec_free(&config.output_names);
+    return ret;
 }
diff --git a/meson.build b/meson.build
index f44cf71..f106c1c 100644
--- a/meson.build
+++ b/meson.build
@@ -97,7 +97,7 @@ clients = {
 		],
 	},
 	'gamma-control': {
-		'src': 'gamma-control.c',
+		'src': ['gamma-control.c', 'str_vec.c'],
 		'dep': [wayland_cursor, math],
 		'proto': ['wlr-gamma-control-unstable-v1'],
 	},
diff --git a/str_vec.c b/str_vec.c
new file mode 100644
index 0000000..558b8be
--- /dev/null
+++ b/str_vec.c
@@ -0,0 +1,30 @@
+#define _XOPEN_SOURCE 700
+#include <stdlib.h>
+#include <string.h>
+
+#include "str_vec.h"
+
+void str_vec_init(struct str_vec *vec) {
+	vec->data = NULL;
+	vec->len = 0;
+}
+
+void str_vec_push(struct str_vec *vec, const char *new_str) {
+	++vec->len;
+	vec->data = realloc(vec->data, vec->len * sizeof(char*));
+	vec->data[vec->len - 1] = strdup(new_str);
+}
+
+void str_vec_free(struct str_vec *vec) {
+	if (vec == NULL) {
+		return;
+	}
+	for (size_t i = 0; i < vec->len; ++i) {
+		if (vec->data[i] != NULL) {
+			free(vec->data[i]);
+		}
+	}
+	free(vec->data);
+	vec->data = NULL;
+	vec->len = 0;
+}
diff --git a/str_vec.h b/str_vec.h
new file mode 100644
index 0000000..f361b39
--- /dev/null
+++ b/str_vec.h
@@ -0,0 +1,15 @@
+#ifndef STR_VEC_H
+#define STR_VEC_H
+
+#include <stddef.h>
+
+struct str_vec {
+	char **data;
+	size_t len;
+};
+
+void str_vec_init(struct str_vec *vec);
+void str_vec_push(struct str_vec *vec, const char *new_str);
+void str_vec_free(struct str_vec *vec);
+
+#endif //STR_VEC_H
-- 
2.51.2

